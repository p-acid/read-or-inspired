---
title: 모노레포 개념 학습
created_at: "2022-05-28"
---

# 등장 배경

## 모놀리식 애플리케이션의 한계

거대한 서비스를 개발할 때, 모듈화 없이 하나의 프로젝트로 구성되면 **코드가 서로 직접적으로 의존**하며 단 하나의 버전으로 관리된다.

그러면 **관심 분리**가 어려워지고 모든 작업이 거대한 단위로 처리되어 비효율을 야기한다.

<br/>

## 모듈화와 재사용성

**모듈화**로 이 문제점을 해결한다.

모듈화는 **애플리케이션 로직의 일부를 재사용**할 수 있도록 하기에 **수정, 교체, 관리에 유용해진다.**

이런 모듈화를 위한 소스 코드의 구조가 **멀티레포**이다.

<br/>

## 멀티레포

말그대로 **여러 레포로 구성된 구조**다.

각 프로젝트는 자율성이 높으며 독립적인 개발, 린트, 테스트, 빌드, 게시, 배포 파이프라인이 존재한다.

위 자율성은 **고립**을 통해 보장되고, 아이러니하게도 고립은 **협업을 방해한다.**

<br/>

## 모노레포의 등장

모노레포는 고립에서 발생하는 문제를 위한 적절한 해결방안이 될 수 있다.

- **더 쉬운 프로젝트 생성**
  - 멀티레포에서 공유 패키지를 만들 때의 과정
    저장소 생성 ⇒ 커미터 추가 ⇒ 개발환경 구축 ⇒ CI/CD 구축 ⇒ 빌드 ⇒ 패키지 저장소(npm)에 배포
    - 저장소 생성, 커미터 추가 필요 없음
    - 개발 환경, CI/CD, 빌드, 게시 등의 과정에 기존 DevOps를 이용  
       ⇒ 새 프로젝트 생성에 대한 오버헤드가 없다.
- **더 쉬운 의존성 관리**
  - 의존성 패키지가 같은 저장소에 있으므로 버전이 지정된 패키지를 npm registry 와 같은 곳에 배포할 필요가 없다.
- **단일화된 관리 포인트**
  - 개발 환경 및 DevOps에 대한 업데이트를 한 번에 반영할 수 있다.
- **일관된 개발자 경험 제공**
  - 애플리케이션을 일관되게 구축하고 테스트할 수 있다.
  - 개발자는 다른 팀의 애플리케이션에 자신 있게 기여하고 변경 사항이 안전한지 확인할 수 있다.
- **프로젝트들에 걸친 원자적 커밋**
  - 커밋할 때마다 모든 것이 함께 작동한다. 변경 사항의 영향을 받는 조직에서 쉽게 변화를 확인할 수 있다.
- **서로 의존하는 저장소들의 리팩터링 비용 감소**

<br/>

## 모노레포가 적절한 상황

하지만 모노레포도 왕도가 아니다. 상황에 맞게 적절하게 사용해야 한다.

다음의 상황에 적절하다 할 수 있다.

- **유사한 제품의 집합**
- **여러 프로젝트의 변화를 한눈에 파악해야 할 때**
- **호스트 애플리케이션을 플러그인 등으로 확장할 때**
- **공통 기능을 재사용하는 관련된 프로젝트의 집합**
- **유사한 DevOps로 구성된 프로젝트의 집합**

<br/>

# 참고 링크

- [NAVER D2 : 모던 프론트엔드 프로젝트 구성 기법 - 모노레포 개념 편](https://d2.naver.com/helloworld/0923884)

<br/>

# 관련 링크 정리

- [배달의 민족 : Yarn berry workspace](https://techblog.woowahan.com/7976/)
- [LINE : Turborepo](https://engineering.linecorp.com/ko/blog/monorepo-with-turborepo/)
- [NAVER D2 : 모던 프론트엔드 프로젝트 구성 기법 - 모노레포 도구 편](https://d2.naver.com/helloworld/7553804)
