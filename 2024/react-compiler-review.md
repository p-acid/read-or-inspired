> - 원문: [I tried React Compiler today, and guess what... 😉](https://www.developerway.com/posts/i-tried-react-compiler)
> - 번역: [Jung Han의 오늘 리액트 컴파일러를 사용해 봤는데, 어땠을 것 같나요? 😉](https://junghan92.medium.com/%EC%98%A4%EB%8A%98-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4-%EB%B4%A4%EB%8A%94%EB%8D%B0-%EC%96%B4%EB%95%A0%EC%9D%84-%EA%B2%83-%EA%B0%99%EB%82%98%EC%9A%94-ece57f076b02)

<br/>

# 리액트 컴파일러란

> [!NOTE]
> 간단하게 말해 모든 것들을 자동으로 메모이제이션(`memo`, `useMemo`, `useCallback` 으로 감싸는 것) 하는 것과 같다.

- 리액트 코어 팀에서 개발한 도구이며 빌드 시스템이 연결하여 원래 컴포넌트의 코드를 가져와 컴포넌트, 프로퍼티 및 훅의 의존성을 기본적으로 메모이제이션 된 코드로 변환하는 시도를 한다.
- 리액트는 계단식으로 리렌더링을 진행하는데, 그 과정에서 불필요한 리렌더링(변경 사항이 없는 컴포넌트의 리렌더링)이 발생하는 것을 막기 위해 메모이제이션을 한다.
- 좀 더 자세한 변환 작업을 이해하기 위해선 [리액트 2024 컨퍼런스 영상](https://www.notion.so/b505ade084ea4fd587f74a2b72f7eaae?pvs=21)를 참고하면 된다.

<br/>

## 리액트 컴파일러 동작 상세

> 원본 영상: [React Compiler: In-Depth Beyond React Conf 2024](https://www.youtube.com/watch?v=PYHBHK37xlE)

- `useMemoCache` 라는 새로운 훅을 통해 캐싱할 수 있는 요소로 구성된 배열을 생성하여 값이나 함수, 컴포넌트를 메모리에 저장하는 효과를 가진다.
  - 인자로 캐시 슬롯 개수를 받는다.
- [컴포넌트의 경우 구조적으로 복잡한 형태도 단일 캐시 항목으로 통합된다.](https://www.youtube.com/watch?v=PYHBHK37xlE&t=377s)
- [상수의 경우, 변경 유무를 감지하여 변경되지 않는 경우 이를 감지하여 별도로 캐싱하지 않는다.](https://www.youtube.com/watch?v=PYHBHK37xlE&t=407s)
- 동적인 값에 의존하는 요소들을 cacheable element로 설정하는 최적화 수행
- `useEffect` 의 경우, 컴파일러는 의존성 배열 내 참조 값의 캐싱에 도움을 줄 수 있다.

<br/>

### 영상 주요 요점

- React 19에는 컴파일러가 포함되지 않는다.
- MobX는 컴파일러와 함꼐 동작하지 않는다.
  - 프록시 기반의 상태 관리는 컴파일러가 빌드 시간에 프록시 사용을 감지할 수 없다.
- 컴파일에만 동작하는 새로운 라이브러리가 예상된다.
- 컴파일러로 인해 리액트의 새로운 시대가 열릴 것이며, 렌더링 모델이 최적화 되면 의존성 배열의 필요성이 없어질 수도 있다.

<br/>

# 리액트 컴파일러 성능 점검

- 리액트 컴파일러의 성능이 기대하는 수준에 미치는지 몇 가지 예시 프로젝트를 통해 테스트 해보았다.
- 기대하는 내용은 다음과 같다.
  - 컴파일러는 PnP 방식으로 설치만 하면 바로 동작하고, 기존 코드를 재작성할 필요가 없어야 할 것이다.
  - 컴파일러 설치 이후엔, `memo`, `useMemo`, `useCallback` 에 대해 다시 생각해볼 필요가 없을 것이다.
- 우선 간단한 예제 작성 이후 리액트 개발자 도구를 통해 확인한 결과 대부분의 컴포넌트가 메모이징 된 결과를 확인.

<br/>

## 간단한 예제 검증 결과

> 예시 레포지토리: [GitHub - developerway/react-compiler-test](https://github.com/developerway/react-compiler-test)

- 모든 케이스들이 성공했으며 문제 없이 동작했다.
- 예제를 확인해보면 의도적으로 메모이징을 진행한 결과와 컴파일러 결과가 동일한 것을 확인할 수 있었다.

<br/>

## 실제 코드에서 컴파일러 테스트

- 결과적으로는 불필요한 리렌더링 발생 구간의 극히 일부분만 수정되었다.
  - 자세한 내용은 원문 테스트 결과를 확인.
- 예시 중 가장 작은 앱을 대상으로 메모이제이션 가능 여부를 분석

<br/>

### 메모이제이션 결과 조사하기

- React Query의 `useMutation` 의 `mutate` 를 구조 분해 할당하여 사용해야 한다.
- 매핑이 되는 컴포넌트를 별도의 컴포넌트로 분리하여 작성해야 한다.
- 매핑 컴포넌트의 `key` 값으로 `index` 를 사용하지 않아야 한다.

<br/>

## 결론

- 기술적으로는 모든 것이 메모이제이션 되기 때문에 문제 없어 보이지만, 실질적으로 메모이제이션을 진행하지 않는 부분들이 있다.
- 아직까지는 렌더링 최적화된 컴포넌트를 작성하기 위한 의식을 가져야 한다.

<br/>

# 개인적 소감

- 컴포넌트와 이에 의존하는 값과 함수를 캐싱하는 메커니즘을 확인하고 나니 생각보다 높은 수준으로 코드를 분석하여 최적화를 진행한다는 사실이 신기했다.
- 리액트 컴파일러를 통해 실질적으로 얼마나 렌더링 최적화가 진행될지 모르겠지만, 프로덕션에서 활용하기 좋은 수준까지 올라온다면 이에 맞는 올바른 코드 작성 방법이 생길 수도 있을 것 같다.
