## 2023-01-01

### [Type challenges](https://github.com/type-challenges/type-challenges)

- Hello world

```typescript
type HelloWorld = string;
```

- 4 Pick

```typescript
type MyPick<T, K extends keyof T> = {
  [key in K]: T[key];
};
```

- Readonly

```typescript
type MyReadonly<T> = { readonly [key in keyof T]: T[key] };
```

- Tuple of Object

```typescript
type TupleToObject<T extends readonly (string | number | symbol)[]> = {
  [key in T[number]]: key;
};
```

- First of Array

```typescript
type First<T extends any[]> = T extends [] ? never : T[0];
```

```typescript
// Other answer : Using "infer" keyword
export type First<T extends any[]> = T extends [infer R, ...any] ? R : never;
```

- Length of Tuple

```typescript
type Length<T extends readonly unknown[]> = T["length"];
```

- My Exclude

```typescript
type MyExclude<T, U> = T extends U ? never : T;
```

### [How is jotai different from zustand?](https://github.com/pmndrs/jotai/issues/13)

- Jotai와 Zustand의 차이점을 설명한 제작자의 깃허브 이슈
- Jotai는 Recoil과 유사하고 Zustand는 Redux와 유사
- Jotai의 상태는 리액트 컴포넌트 트리 내에 있고, Zustand의 상태는 리액트 밖 store에 있다.
- 주된 차이는 상태 모델에 있다.
  - Zustand는 기본적으로 하나의 store이고, Jotai는 primitive atoms들이 이를 구성한다.
  - 이런 맥락에서 위 논의는 프로그래밍 정신 모델의 문제이다.
  - Jotai는 여러 Context를 생성하는 것을 atom을 통해 대체해여 useState와 useContext를 대체하는 느낌이라면, Zustand는 외부 store를 의미하며 Hook은 외부와 리액트를 연결하는 느낌

각자 이럴 때 쓰면 좋다.

- Zustand
  - 리액트 밖에서 상태를 업데이트 시키고 싶다
  - Redux devtools가 익숙하다.
  - zustand가 두 개의 리액트 렌더러 사이에서 전역 상태의 공유가 필요한 경우(Jotai의 no-provider 모드로 호환은 가능하지만, Zustand가 아마 더 잘 동작할 것이라고 함)
- Jotai
  - useState + useContext를 대체하고 싶다
  - code splitting이 중요하다고 생각한다
  - Suspense와 함께 활용하고 싶다.

> 해당 이슈에서 "내부 상태"(Internal state)와 "외부 상태"(External state)의 정의: React.useState가 내부 상태고 이외는 다 외부 상태

> CM은 [Concurrent Mode](https://reactjs.org/blog/2022/03/29/react-v18.html#what-is-concurrent-react)

<br/>

## 2023-01-02

### [Type challenges](https://github.com/type-challenges/type-challenges)

- Awaited

```typescript
type MyAwaited<T extends PromiseLike<any>> = T extends PromiseLike<infer U>
  ? U extends PromiseLike<any>
    ? MyAwaited<U>
    : U
  : never;
```

- If

```typescript
type If<C extends boolean, T, F> = C extends true ? T : F;
```

### [스윙스, 생각을 많이 하는 것이 위험한 이유는?](https://www.youtube.com/watch?v=LaBlk7fGIb0)

영상 요약

- 생각을 줄일수록 성공할 확률이 조금씩 늘어난다.
- 생각을 과하게 하는 것(Overthinking)은 괴로운 일이다.
- 상상의 세계가 현재의 즐거움들을 소진시키고 공포만을 남긴다.
- 맞으면서 적응하라. 매 상황마다 대응 방식이 다를 것이다.
- 어차피 결론이 없을 것이면 왜 고민을 길게 하는 것인가?
- 나의 잡념을 없앨 최고의 환경을 구하라. 그렇기에 좋은 회사도 중요하다.

나의 사견

- 나의 가장 큰 단점은 위에서 언급한 "과한 고민"이었다.
- 올해의 나는 고민을 행동으로 돌리기 위해 노력한 한해였다.
- 이전보다 한 단계 나아졌다고는 확신할 수 있다.
- 다만, 빠르게 행동하기 위해서 명확한 근거를 확보하는 능력을 더욱 키우는 것이 좋다고 판단된다.
- 예를 들어, 적용하고 싶은 기술 내지 방법론이 존재한다면 **상대방을 설득할 만한 매력적인 요소를 발견**하여 이를 **조리있게 설명하는 능력**을 갖추는 것도 좋을 것이다.

<br/>

## 2023-01-03

### [Type challenges](https://github.com/type-challenges/type-challenges)

- Concat

```typescript
type Concat<T extends unknown[], U extends unknown[]> = [ ...T, ...U ]
```

- Includes

```typescript
type Includes<T extends readonly any[], U> = T extends [infer First, ...infer Rest] ? Equal<First, U> extends true ? true : Includes<Rest, U> : false
```

> [Reference](https://nickangeli.com/posts/typescript-type-challenge-includes-walkthrough/)

- Push

```typescript
type Push<T extends any[], U> = [ ...T, U ]
```

- Unshift

```typescript
type Unshift<T extends any[], U> = [ U, ...T ]
```

- Parameters

```typescript
type MyParameters<T extends (...args: any[]) => any> = T extends (...args: infer A) => any ? A : []
```

<br/>

## 2023-01-04

### [Type challenges](https://github.com/type-challenges/type-challenges)

- Get Return Type

```typescript
type MyReturnType<T> = T extends (...args: any) => infer R ? R : T
```

- Omit

```typescript
type MyOmit<T, K extends keyof T> = { [P in Exclude<keyof T, K>]: T[P] }
```

<br/>

## 2023-01-06

### [Type challenges](https://github.com/type-challenges/type-challenges)

- Readonly 2

```typescript
// My answer: has 1 error
type MyReadonly2<T, K extends keyof T> = { readonly [A in K]: T[A] } & { [B in Exclude<keyof T, K>]: T[B] }

// Final answer: Add default type to K
type MyReadonly2<T, K extends keyof T = keyof T> = { readonly [A in K]: T[A] } & { [B in Exclude<keyof T, K>]: T[B] }
```

- Deep Readonly
  - 객체 재귀 타입

```typescript
type DeepReadonly<T> = { readonly [P in keyof T]: T[P] extends object ? T[P] extends Function ? T[P] : DeepReadonly<T[P]> : T[P] }
```

<br/>

## 2023-01-08

### [Type challenges](https://github.com/type-challenges/type-challenges)


- Tuple to Union

```typescript
type TupleToUnion<T extends any[]> = T[number] extends infer A ? A : never

// shortcut
type TupleToUnion<T extends unknown[]> = T[number]
```

- Chainable Options
  - 에러 핸들링 : 인자로 받는 `key` 의 값이 `O` 의 `key` 에 포함되는 경우 `never`(공타입) 할당
  - 오버라이딩: `Omit<O, K>` 로 `K` 와 동일한 `key` 에 해당하는 값 필드 제거 후 `{ [key in K]: V }` 타입 추가

```typescript
type Chainable<O = {}> = {
  option<K extends string, V>(key: K extends keyof O ? never : K, value: V): Chainable<Omit<O, K> & { [key in K]: V }> 
  get(): O
}
```

<br/>

## 2023-01-09

### [Type challenges](https://github.com/type-challenges/type-challenges)

- Last of Array

```typescript
type Last<T extends unknown[]> = T extends [ ...infer _U, infer R ] ? R : never
```

- Pop

```typescript
type Pop<T extends any[]> = T['length'] extends 0 ? [] : T extends [ ...infer R, infer _L ] ? R : never
```

### [Integrate Tailwind CSS and Storybook](https://storybook.js.org/recipes/tailwindcss)

- Init

```sh
npx sb init --builder webpack5
```

- Add postcss addon

```js
module.exports = {
  ...,
  addons: [
    ...,
    {
      name: '@storybook/addon-postcss',
      options: {
        cssLoaderOptions: {
          importLoaders: 1
        },
        postcssLoaderOptions: {
          implementation: require('postcss')
        }
      }
    }
  ],
  ...
}
```

- Add `Import`

```js
// .storybook/preview.js
import '../styles/globals.css'
```

<br/>

## 2023-01-11

### [Type challenges](https://github.com/type-challenges/type-challenges)

- Promise.all
  - 함수 타입 선언
    - 인자 타입 `readonly` : `as const` 대응
    - 반환 타입 배열 객체 : `Promise` 타입일 경우, `Promise` 타겟 반환, 아니면 배열의 해당 인덱스
   - 마지막 케이스만 통과 못한 답안
     ```typescript
     // 마지막 케이스
     const promiseAllTest4 = PromiseAll<Array<number | Promise<number>>>([1, 2, 3])
     
     Expect<Equal<typeof promiseAllTest4, Promise<number[]>>>
     ```

```typescript
declare function PromiseAll<T extends unknown[]>(values: readonly [...T]): Promise<{ [P in keyof T]: T[P] extends Promise<infer R> ? R : T[P] }>
```

- `Awaited` 활용하여 통과
  - 앞의 코드에서 재귀를 진행하지 않아 문제였음 : `Promise` 배열 내 `Promise` 객체가 있을 경우 `resolve` 된 값을 온전히 반환하기 위함
  - 재귀 타입 추가한 답안 추가

```typescript
// Awaited 활용
declare function PromiseAll<T extends any[]>(values: readonly [...T]): Promise<{
  [P in keyof T]: Awaited<T[P]>
}>

// 재귀 타입
type PromiseFlat<T> = T extends Promise<infer K> ? PromiseFlat<K> : T

declare function PromiseAll<T extends any[]>(values: readonly [...T]): Promise<{
  [K in keyof T]: PromiseFlat<T[K]>
}>
```

- Type Lookup

```typescript
type LookUp<U extends { type: unknown }, T extends U["type"]> = U extends { type: T } ? U : never
```


<br/>

## 2023-01-12

### [Type challenges](https://github.com/type-challenges/type-challenges)

- Trim Left
  - 템플릿 리터럴 활용한 답안

```typescript
type TrimLeft<S extends string> = S extends ` ${infer L extends string}${infer R extends string}` 
  ? TrimLeft<`${L}${R}`> 
    : S extends `\n${infer R}` | `\t${infer R}` 
  ? TrimLeft<R> 
    : S
```

- 공백 타입(`Space`)을 정의한 답안

```typescript
// your answers
type Space = ' ' | '\n' | '\t'
type TrimLeft<S extends string> = S extends `${Space}${infer R}` ? TrimLeft<R> : S
```

- Trim
  - Trim Left 확장 답안

```typescript
type Space = ' ' | '\n' | '\t'

type Trim<S extends string> = S extends `${Space}${infer R}` | `${infer R}${Space}` ? Trim<R> : S
```

- Capitalize

```typescript
type MyCapitalize<S extends string> = S extends `${infer C}${infer L}` ? `${Capitalize<C>}${L}` : S
```

<br/>

## 2023-01-13

### [Type challenges](https://github.com/type-challenges/type-challenges)

- Replace

```typescript
type Replace<S extends string, From extends string, To extends string> = From extends '' 
  ? S 
    : S extends `${infer L}${From}${infer R}` 
  ? `${L}${To}${R}` 
    : S
```

<br/>

## 2023-01-14

### [Type challenges](https://github.com/type-challenges/type-challenges)

- Replace All

```typescript
type ReplaceAll<S extends string, From extends string, To extends string> = From extends '' 
  ? S 
    : S extends `${infer L}${From}${infer R}` 
  ? `${L}${To}${ReplaceAll<`${R}`, From, To>}` 
    : S
```

- Append Argument

```typescript
type AppendArgument<Fn extends Function, A> = Fn extends (...args: infer L) => infer R 
  ? (...args: [...L, A]) => R 
    : never
```

<br/>

## 2023-01-15

### [Type challenges](https://github.com/type-challenges/type-challenges)

- Permutation

```typescript
type Permutation<T, C = T> = [T] extends [never]
  ? []
  : C extends infer U
  ? [U, ...Permutation<Exclude<T, U>>]
  : [];
```


### [How to mock Next.js `useRouter` in Storybook](https://storybook.js.org/addons/storybook-addon-next-router)

```js
// .storybook/main.js

module.exports = {
  ...config,
  addons: [
    ...your addons
    "storybook-addon-next-router",
  ],
};
```

```js
// .storybook/preview.js

import { RouterContext } from "next/dist/shared/lib/router-context"; // next 12

export const parameters = {
  nextRouter: {
    Provider: RouterContext.Provider,
  },
}
```
