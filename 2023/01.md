## 2023-01-01

### [Type challenges](https://github.com/type-challenges/type-challenges)

- Hello world

```typescript
type HelloWorld = string;
```

- 4 Pick

```typescript
type MyPick<T, K extends keyof T> = {
  [key in K]: T[key];
};
```

- Readonly

```typescript
type MyReadonly<T> = { readonly [key in keyof T]: T[key] };
```

- Tuple of Object

```typescript
type TupleToObject<T extends readonly (string | number | symbol)[]> = {
  [key in T[number]]: key;
};
```

- First of Array

```typescript
type First<T extends any[]> = T extends [] ? never : T[0];
```

```typescript
// Other answer : Using "infer" keyword
export type First<T extends any[]> = T extends [infer R, ...any] ? R : never;
```

- Length of Tuple

```typescript
type Length<T extends readonly unknown[]> = T["length"];
```

- My Exclude

```typescript
type MyExclude<T, U> = T extends U ? never : T;
```

### [How is jotai different from zustand?](https://github.com/pmndrs/jotai/issues/13)

- Jotai와 Zustand의 차이점을 설명한 제작자의 깃허브 이슈
- Jotai는 Recoil과 유사하고 Zustand는 Redux와 유사
- Jotai의 상태는 리액트 컴포넌트 트리 내에 있고, Zustand의 상태는 리액트 밖 store에 있다.
- 주된 차이는 상태 모델에 있다.
  - Zustand는 기본적으로 하나의 store이고, Jotai는 primitive atoms들이 이를 구성한다.
  - 이런 맥락에서 위 논의는 프로그래밍 정신 모델의 문제이다.
  - Jotai는 여러 Context를 생성하는 것을 atom을 통해 대체해여 useState와 useContext를 대체하는 느낌이라면, Zustand는 외부 store를 의미하며 Hook은 외부와 리액트를 연결하는 느낌

각자 이럴 때 쓰면 좋다.

- Zustand
  - 리액트 밖에서 상태를 업데이트 시키고 싶다
  - Redux devtools가 익숙하다.
  - zustand가 두 개의 리액트 렌더러 사이에서 전역 상태의 공유가 필요한 경우(Jotai의 no-provider 모드로 호환은 가능하지만, Zustand가 아마 더 잘 동작할 것이라고 함)
- Jotai
  - useState + useContext를 대체하고 싶다
  - code splitting이 중요하다고 생각한다
  - Suspense와 함께 활용하고 싶다.

> 해당 이슈에서 "내부 상태"(Internal state)와 "외부 상태"(External state)의 정의: React.useState가 내부 상태고 이외는 다 외부 상태

> CM은 [Concurrent Mode](https://reactjs.org/blog/2022/03/29/react-v18.html#what-is-concurrent-react)

<br/>

## 2023-01-02

### [Type challenges](https://github.com/type-challenges/type-challenges)

- Awaited

```typescript
type MyAwaited<T extends PromiseLike<any>> = T extends PromiseLike<infer U>
  ? U extends PromiseLike<any>
    ? MyAwaited<U>
    : U
  : never;
```

- If

```typescript
type If<C extends boolean, T, F> = C extends true ? T : F;
```

### [스윙스, 생각을 많이 하는 것이 위험한 이유는?](https://www.youtube.com/watch?v=LaBlk7fGIb0)

영상 요약

- 생각을 줄일수록 성공할 확률이 조금씩 늘어난다.
- 생각을 과하게 하는 것(Overthinking)은 괴로운 일이다.
- 상상의 세계가 현재의 즐거움들을 소진시키고 공포만을 남긴다.
- 맞으면서 적응하라. 매 상황마다 대응 방식이 다를 것이다.
- 어차피 결론이 없을 것이면 왜 고민을 길게 하는 것인가?
- 나의 잡념을 없앨 최고의 환경을 구하라. 그렇기에 좋은 회사도 중요하다.

나의 사견

- 나의 가장 큰 단점은 위에서 언급한 "과한 고민"이었다.
- 올해의 나는 고민을 행동으로 돌리기 위해 노력한 한해였다.
- 이전보다 한 단계 나아졌다고는 확신할 수 있다.
- 다만, 빠르게 행동하기 위해서 명확한 근거를 확보하는 능력을 더욱 키우는 것이 좋다고 판단된다.
- 예를 들어, 적용하고 싶은 기술 내지 방법론이 존재한다면 **상대방을 설득할 만한 매력적인 요소를 발견**하여 이를 **조리있게 설명하는 능력**을 갖추는 것도 좋을 것이다.

<br/>

## 2023-01-03

### [Type challenges](https://github.com/type-challenges/type-challenges)

- Concat

```typescript
type Concat<T extends unknown[], U extends unknown[]> = [ ...T, ...U ]
```

- Includes

```typescript
type Includes<T extends readonly any[], U> = T extends [infer First, ...infer Rest] ? Equal<First, U> extends true ? true : Includes<Rest, U> : false
```

> [Reference](https://nickangeli.com/posts/typescript-type-challenge-includes-walkthrough/)

- Push

```typescript
type Push<T extends any[], U> = [ ...T, U ]
```

- Unshift

```typescript
type Unshift<T extends any[], U> = [ U, ...T ]
```

- Parameters

```typescript
type MyParameters<T extends (...args: any[]) => any> = T extends (...args: infer A) => any ? A : []
```

<br/>

## 2023-01-04

### [Type challenges](https://github.com/type-challenges/type-challenges)

- Get Return Type

```typescript
type MyReturnType<T> = T extends (...args: any) => infer R ? R : T
```


