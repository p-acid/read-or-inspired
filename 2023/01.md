## 2023-01-01

### [Type challenges](https://github.com/type-challenges/type-challenges)

- Hello world

```typescript
type HelloWorld = string
```

- 4 Pick

```typescript
type MyPick<T,K extends keyof T>={
  [key in K]: T[key]
}
```

- Readonly

```typescript
type MyReadonly<T> = { readonly [key in keyof T]: T[key] } 
```

- Tuple of Object

```typescript
type TupleToObject<T extends readonly (string | number | symbol)[]> = {
  [key in T[number]]: key
}
```

- First of Array

```typescript
type First<T extends any[]> = T extends [] ? never : T[0]
```

```typescript
// Other answer : Using "infer" keyword
export type First<T extends any[]> = T extends [infer R, ...any]
  ? R
  : never
```

- Length of Tuple

```typescript
type Length<T extends readonly unknown[]> = T['length']
```

- My Exclude

```typescript
type MyExclude<T, U> = T extends U ? never : T
```

### [How is jotai different from zustand?](https://github.com/pmndrs/jotai/issues/13)

- Jotai와 Zustand의 차이점을 설명한 제작자의 깃허브 이슈
- Jotai는 Recoil과 유사하고 Zustand는 Redux와 유사
- Jotai의 상태는 리액트 컴포넌트 트리 내에 있고, Zustand의 상태는 리액트 밖 store에 있다.
- 주된 차이는 상태 모델에 있다. 
  - Zustand는 기본적으로 하나의 store이고, Jotai는 primitive atoms들이 이를 구성한다.
  - 이런 맥락에서 위 논의는 프로그래밍 정신 모델의 문제이다.
  - Jotai는 여러 Context를 생성하는 것을 atom을 통해 대체해여 useState와 useContext를 대체하는 느낌이라면, Zustand는 외부 store를 의미하며 Hook은 외부와 리액트를 연결하는 느낌

각자 이럴 때 쓰면 좋다.

- Zustand
  - 리액트 밖에서 상태를 업데이트 시키고 싶다
  - Redux devtools가 익숙하다.
  - zustand가 두 개의 리액트 렌더러 사이에서 전역 상태의 공유가 필요한 경우(Jotai의 no-provider 모드로 호환은 가능하지만, Zustand가 아마 더 잘 동작할 것이라고 함)
- Jotai
  - useState + useContext를 대체하고 싶다
  - code splitting이 중요하다고 생각한다
  - Suspense와 함께 활용하고 싶다.

> 해당 이슈에서 "내부 상태"(Internal state)와 "외부 상태"(External state)의 정의: React.useState가 내부 상태고 이외는 다 외부 상태

> CM은 [Concurrent Mode](https://reactjs.org/blog/2022/03/29/react-v18.html#what-is-concurrent-react)



