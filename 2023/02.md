## 2023-02-01

### [Type challenges](https://github.com/type-challenges/type-challenges)

- ReplaceKeys (Failed)

```typescript
type ReplaceKeys<U, T, Y> = {
  [Key in keyof U]: Key extends T
    ? Key extends keyof Y
      ? Y[Key]
      : never
    : U[Key];
};
```

- Remove Index Signature (Failed)
  - 역으로 시그니처 키 타입에 해당하는 타입들을 `extends` 로 비교하여 시그니쳐 인덱스 구별

```typescript
type SignatureKey = string | number | symbol;

type RemoveIndexSignature<T> = {
  [Key in keyof T as SignatureKey extends keyof T[Key] ? never : Key]: T[Key];
};
```

## 2023-02-02

### [Type challenges](https://github.com/type-challenges/type-challenges)

- Percentage Parser (Failed)

```typescript
type PercentageParser<A extends string> = A extends `${infer Sign}${infer B}`
  ? Sign extends SignType
    ? [Sign, ...(B extends `${infer Number}%` ? [Number, "%"] : [B, ""])]
    : ["", ...(A extends `${infer Number}%` ? [Number, "%"] : [A, ""])]
  : ["", "", ""];
```

- Drop Char

```typescript
type DropChar<
  S extends string,
  C extends string
> = S extends `${infer L}${C}${infer R}` ? `${DropChar<`${L}${R}`, C>}` : S;
```

## 2023-02-06

### [Type challenges](https://github.com/type-challenges/type-challenges)

- Minus One (failed)

```typescript
// 문자열을 앞 뒤로 바꿔주는 타입 제네릭: '123' -> '321'
type Reverse<
  S extends string,
  A extends string = ""
> = S extends `${infer F}${infer R}` ? Reverse<R, `${F}${A}`> : A;

//  숫자에서 1을 빼는 타입 제네릭 : '1' -> '0', '5' -> '4', '0' -> '9'
type DigitMinusOne<D extends string> =
  "09876543210" extends `${string}${D}${infer R}${string}` ? R : never;

// 뒤집어진 숫자에서 1을 빼는 타입 제네릭: '5' -> '4', '01' -> '9', '51' -> '41', '001' -> '99'
type RevMinusOne<T extends string> = T extends `${infer F}${infer N}${infer R}`
  ? // 만약, T가 두 자릿수 이상의 숫자라면
    F extends "0"
    ? `9${RevMinusOne<`${N}${R}`>}`
    : `${DigitMinusOne<F>}${N}${R}`
  : // 만약, T가 한 자릿수 숫자라면
  T extends "0"
  ? "1-"
  : T extends "1"
  ? ""
  : DigitMinusOne<T>;

// 1을 더하는 타입 제네릭: '0' -> '1', '4' -> '9', '9' -> '0'
type DigitPlusOne<D extends string> =
  "01234567890" extends `${string}${D}${infer R}${string}` ? R : never;

// 뒤집어진 숫자에서 1을 더하는 타입 제네릭: '4' -> '9', '9' -> '01', '41' -> '51', '99' -> '001'
type RevPlusOne<T extends string> = T extends `${infer F}${infer N}${infer R}`
  ? // if `T` is a multi-digit number like '01', '55' or '123'
    F extends "9"
    ? `0${RevPlusOne<`${N}${R}`>}`
    : `${DigitPlusOne<F>}${N}${R}`
  : // if `T` is a single-digit number like '0', '1' or '8'
  T extends "9"
  ? "01"
  : DigitPlusOne<T>;

/*
 * 최종 타입 제네릭
 */
type MinusOne<T extends number> = `${T}` extends `-${infer AbsT}`
  ? // 만약, T가 음수일 경우 절댓값에 1을 더하고 "-" 사인을 붙여줌
    `-${Reverse<
      RevPlusOne<Reverse<AbsT>>
    >}` extends `${infer Res extends number}`
    ? Res
    : never
  : // 양수일 경우, 마이너스를
  Reverse<RevMinusOne<Reverse<`${T}`>>> extends `${infer Res extends number}`
  ? Res
  : 0;
```

- PickByType

```typescript
type PickByType<T, U> = {
  [Key in keyof T as T[Key] extends U ? Key : never]: T[Key];
};
```

- StartsWith

```typescript
type StartsWith<T extends string, U extends string> = T extends `${U}${string}`
  ? true
  : false;
```

- EndsWith

```typescript
type EndsWith<T extends string, U extends string> = T extends `${string}${U}`
  ? true
  : false;
```

### 최신 웹 브라우저 살펴보기 (1부)

> 원본 글 : [Inside look at modern web browser (part 1)](https://developer.chrome.com/blog/inside-browser-part1/)
>
> 1부 내용 : 핵심 컴퓨팅 용어와 크롬 다중 프로세스 아키텍쳐

- 컴퓨터의 핵심은 CPU와 GPU
  - 브라우저 실행 환경을 이해하기 위한 컴퓨터 부품
  - CPU(Central Processing Unit)
    - 중앙 처리 장치
    - 다양한 작업을 하나씩 처리할 수 있다.
    - 과거에는 대부분 단일 칩이었으나, 최신 하드웨어는 둘 이상의 코어로 더 좋은 성능을 제공하는 경우가 많다.
  - GPU(Graphics Processing Unit)
    - 그래픽 처리 장치
    - CPU와 달리 간다한 작업을 처리하며, 여러 코어에 걸쳐있다.
    - 그래픽 처리를 위한 장치
    - 최근 몇 년 동안 GPU 가속 컴퓨팅을 통한 GPU 단독 컴퓨팅이 가능해지고 있다.
  - 일반적으로 응용프로그램은 운영 체제에서 제공하는 메커니즘을 사용하여 CPU 및 GPU에서 실행된다.
- 프로세스 및 스레드에서 프로그램 및 실행
  - 응용 프로그램 실행으로 설명하는 프로세스와 스레드
    1. 응용 프로그램 시작 및 프로세스 생성
    2. 운영 체제가 작업할 메모리의 공간을 프로세스에 제공
    3. 모든 애플리케이션 상태를 해당 메모리 공간에 보관
    4. 응용 프로그램을 닫으면 프로세스도 사라지고 운영 체제에서 메모리를 확보
  - 프로세스는 다른 작업을 실행하기 위해 운영 체제에 요청할 수 있다.
  - 이러면, 메모리 다른 부분이 새 프로세스에 할당
  - 두 프로세스가 통신해야 하는 경우 **IPC(Inter Process Communication)**를 사용하여 가능
  - 많은 응용 프로그램은 작업자 프로세스가 응답하지 않은 경우, 응용 프로그램의 다른 부분을 실행하는 다른 프로세스를 중단하지 않고 다시 시작할 수 있도록 이러한 방식으로 설계되었다.
- 브라우저 아키텍쳐
  - 프로세스와 스레드를 사용하여 웹 브라우저를 구축하는 방법
    - 여러 스레드가 있는 하나의 프로세스이거나 IPC를 통해 통신하는 여러 프로세스일 수 있다.
    - 중요한 점은, 서로 다른 아키텍쳐가 구현 세부 사항이라는 것이다.
    - 웹 브라우저를 구축하는 표준 사양은 없다.
    - 한 브라우저의 접근 방식은 다른 브라우저와 완전히 다를 수 있다.
    - 해당 글에선 크롬 최신 아키텍쳐를 사용한다.
  - 크롬 아키텍쳐
    - 맨 위에는 응용 프로그램의 다른 부분을 관리하고 다른 프로세스와 조정되는 브라우저 프로세스가 있다.
    - 렌더러 프로세스의 경우 여러 프로세스가 생성되어 각 탭에 할당된다.
      - 아주 최근까지 크롬은 가능한 경우 각 탭에 프로세스를 제공했다.
      - 하지만 이제 `iframe` 을 포함하여 각 사이트에 자체 프로세스를 제공하려 시도한다.
- 프로세스 목록

  | 제어 대상 | 설명                                                                                                                                                                                     |
  | --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
  | 브라우저  | 주소 표시줄, 북마크, 뒤로 및 앞으로 버튼을 포함하여 애플리케이션의 크롬 부분을 제어한다. <br/> 또한, 네트워크 요청 및 파일 액세스와 같은 웹 브라우저의 보이지 않는 권한 부분을 처리한다. |
  | 렌더러    | 웹사이트가 표시되는 탭 내부의 모든 것을 제어한다.                                                                                                                                        |
  | 플러그인  | 예를 들어, 플래시와 같이 웹 사이트에서 사용하는 모든 플러그인을 제어한다.                                                                                                                |
  | GPU       | 다른 프로세스와 별도로 GPU 작업을 처리한다. <br/> GPU가 여러 앱의 요청을 처리하고 동일한 표면에 그리기 때문에 다른 프로세스로 분리된다.                                                  |

  <br/>

  - 이외에도 확장 프로세스 및 유틸리티 프로세스 등도 존재한다.
  - 크롬에서 실행 중인 프로세스 수를 확인하려면 오른쪽 상단 모서리에 있는 옵션 메뉴 아이콘을 클릭하고 도구 더보기에서 작업 관리자를 열면 된다.
  - 그러면 현재 실행 중인 프로세스 목록과 사용 중인 CPU/메모리 양이 표시된 창이 열린다.

- 크롬 다중 프로세스 아키텍쳐의 이점
  - 크롬은 **다중 렌더러 프로세스**를 사용한다.
    - 간단하게 각 탭에 자체 렌더러 프로세스가 있다고 생각할 수 있다.
    - 3개의 탭이 열려 있고 각 탭이 독립적인 렌더러 프로세스에 의해 실행된다고 가정했을 때, 한 탭이 응답하지 않으면, 응답하지 않는 탭을 닫고 다른 탭을 활성 상태로 유지하면서 계속 진행할 수 있다.
    - 모든 탭이 한 프로세스라면, 한 탭이 응답하지 않을 때 모든 탭이 응답하지 않는다.
  - 브라우저 작업을 여러 프로세스로 분리하는 또 다른 이점은 보안 및 샌드박싱이다.
    - 운영 체제는 프로세스 권한을 제한하는 방법을 제공하기에 브라우저는 특정 기능에서 특정 프로세스를 샌드박싱할 수 있다.
      - 샌드박싱이란 외부로부터 들어온 프로그램이 보호된 영역에서 동작해 시스템이 부정하게 조작되는 것을 막는 보안 형태
    - 예를 들어, 크롬 브라우저는 렌더러 프로세스와 같이 임의의 사용자 입력을 처리하는 프로세스에 대한 임의 파일 액세스를 제한한다.
  - 프로세스에는 고유한 개인 메모리 공간이 있기 때문에 공통 인프라(예를 들어, 크롬의 자바스크립트 엔진인 V8)의 복사본을 포함하는 경우가 많다.
    - 이는 동일한 프로세스 내부의 스레드인 경우 공유할 수 없기 때문에, 더 많은 메모리 사용량을 의미한다.
    - 메모리를 절약하기 위해 크롬은 가동할 수 있는 프로세스 수를 제한한다.
    - 한도는 기기의 메모리 및 CPU 성능에 따라 다르지만, 크롬이 한도에 도달하면 한 프로세스에서 동일한 사이트의 여러 탭을 실행하기 시작한다.
- 더 많은 메모리 절약 - 크롬의 서비스
  - 동일한 접근 방식이 브라우저 프로세스에 적용된다.
    - 크롬은 브라우저 프로그램의 각 부분을 서비스로 실행하여, 여러 프로세스로 쉽게 분할하거나 하나로 통합할 수 있도록 아키텍쳐를 변경하고 있다.
  - 일반적으로 크롬이 강력한 하드웨어에서 실행될 때엔 각 서비스를 다른 프로세스로 분할하여 더 많은 안정성을 제공한다.
    - 하지만, 리소스가 제한된 장치에 있는 경우 크롬은 서비스를 하나의 프로세스로 통합하여 메모리 공간을 절약한다.
    - 메모리 사용량을 줄이기 위해 프로세스를 통합하는 유사한 접근 방식이 안드로이드와 같은 플랫폼에서 사용되었다.
- 프레임 별 렌더러 프로세스 - 사이트 격리
  - 사이트 격리는 각 교차 사이트 `iframe` 에 대해 렌더러 프로세스를 실행하는 최근 도입된 크롬의 기능이다.
  - 우리는 서로 다른 사이트 간에 메모리 공간을 공유하는 단일 렌더러 프로세스에서 사이트 간 `iframe` 을 실행할 수 있는 탭 모델당 하나의 렌더러 프로세스에 대해 이야기했다.
  - 동일한 렌더러 프로세스에서 두 가지 웹 사이트(a.com, b.com)를 실행하는 것이 괜찮아보일 수 있다.
    - 동일 출처 정책은 웹의 핵심 보안 모델이다.
    - 한 사이트가 동의 없이 다른 사이트의 데이터에 액세스 할 수 없도록 한다.
    - 이 정책을 우회하는 것이 보안 공격의 주요 목표이다.
  - 프로세스 격리는 사이트를 분리하는 가장 효과적인 방법이다.
    - 멜트다운과 스펙터로 프로세스를 사용하여 사이트를 분리해야 한다는 것이 더욱 분명해졌다.
    - 크롬 67부터 기본적으로 데스크톱에서 사이트 격리가 활성화되어 있으므로 탭의 각 교차 사이트 `iframe` 은 별도의 렌더러 프로세스를 가져온다.
  - 사이트 격리를 활성화 하는 것은 다년간의 엔지니어링 노력에서 비롯된다.
    - 사이트 격리는 다른 렌더러 프로세스를 할당하는 것처럼 간단하지 않다.
    - `iframe` 이 서로 커뮤니케이션 하는 방식을 근본적으로 바꾼다.
    - 다른 프로세스에서 실행되는 `iframe` 이 있는 페이지에서 개발자 도구를 여는 것은 개발자 도구가 매끄럽게 보이도록 백그라운드 작업을 구현해야 한다는 것을 의미한다.
    - 페이지에서 단어를 찾기 위해 Ctrl+F를 실행하는 것조차 다른 렌더러 프로세스에서 검색하는 것을 의미한다.
    - 브라우저 엔지니어가 사이트 격리 릴리스를 주요 이정표로 언급하는 이유를 알 수 있다.

> 다음: [Inside look at modern web browser (part 2)](https://developer.chrome.com/blog/inside-browser-part2/)

<br/>

## 2023-02-07

### [How to make compound component with `forwardRef`](https://stackoverflow.com/questions/70202711/how-to-attach-a-compound-component-when-using-react-forward-ref-property-does-n)

- 타입 확장 및 객체 `export` 방식

```tsx
interface IPanel
  extends React.ForwardRefExoticComponent<
    PanelProps & React.RefAttributes<HTMLDivElement>
  > {
  Header: typeof PanelHeader;
  Content: typeof PanelContent;
}
```

```tsx
const forwardRef = React.forwardRef<HTMLDivElement, PanelProps>(
  (props, ref): JSX.Element => {
    return (
      <PanelComponent
        {...props}
        forwardedRef={ref}
        data-testid={PANEL_TEST_ID}
      />
    );
  }
);

export const Panel = {
  ...forwardRef,
  Header: PanelHeader,
  Content: PanelContent,
} as IPanel;
```

- `Object.assign` 방식

```tsx
export const Panel = Object.assign(
  React.forwardRef(
    (props: PanelProps, ref: React.Ref<HTMLDivElement>): JSX.Element => {
      return (
        <PanelComponent
          {...props}
          forwardedRef={ref}
          data-testid={PANEL_TEST_ID}
        />
      );
    }
  ),
  {
    Header: PanelHeader,
    Content: PanelContent,
  }
);
```

### 최신 웹 브라우저 살펴보기 (2부)

> 원본 글 : [Inside look at modern web browser (part 2)](https://developer.chrome.com/blog/inside-browser-part2/)
>
> 2부 내용 : 네비게이션에서 일어나는 일
>
> - 해당 글에선 **웹 사이트를 표시하기 위해 각 프로세스와 스레드가 통신하는 방법**에 대해 자세히 설명한다.
> - 웹 브라우징의 간단한 사례
>   - 브라우저에 URL을 입력하면 브라우저가 인터넷에서 데이터를 가져와 페이지를 표시
> - **사용자가 사이트를 요청**하고, **브라우저가 페이지를 렌더링할 준비를 하는 부분(네비게이션)**에 중점을 둘 것이다.

- 브라우저 프로세스로 시작합니다.
  - 1부에서 다룬 것처럼 **탭 외부의 모든 것은 브라우저 프로세스에서 처리**된다.
  - 브라우저 프로세스에는
    - 브라우저의 버튼과 입력 필드 등을 그리는 **UI 스레드**,
    - 인터넷에서 데이터 수신을 하기 위해 네트워크 스택을 처리하는 **네트워크 스레드**
    - 파일에 대한 액세스를 제어하는 **스토리지 스레드** 등과 같은 스레드가 있다.
  - 주소 표시줄에 UR을 입력하면 브라우저 프로세스의 UI 스레드에서 입력을 처리한다.
- 간단한 탐색
  - 1단계: 입력 처리
    - 사용자가 주소 표시줄에 입력하기 시작하면 UI 스레드에서 가장 먼저 묻는 것은 **"이것이 검색어인가요? 아님, URL인가요?"**이다.
    - 크롬에서 주소 표시줄은 검색 입력 필드이기도 하므로 UI 스레드는 **사용자를 검색 엔진으로 보낼지 또는 요청한 사이트로 보낼지 여부를 구문 분석하고 결정**해야 한다.
  - 2단계: 네비게이션 시작
    - 사용자가 엔터키를 누르면 UI 스레드가 네트워크 호출을 시작하여 사이트 콘텐츠를 가져온다.
    - 로딩 스피너는 탭 모서리에 표시되며, **네트워크 스레드**는 **DNS 조회 및 요청에 대한 TLS 연결 설정**과 같은 적절한 프로토콜을 거친다.
      > **DNS(Domain Name System)**: 사람이 읽을 수 있는 **도메인 이름**을 기계가 읽는 **IP 주소**로 변환하는 것
      >
      > **TLS(Transport Layer Security)**: 인터넷 커뮤니케이션을 위한 **개인 정보와 데이터 무결성을 제공하는 보안 프로토콜**
    - 이 시점에서 네트워크 스레드는 HTTP 301과 같은 서버 리디렉션 헤더를 수신할 수 있다.
    - 이 경우, 네트워크 스레드는 서버가 리다이렉션을 요청하는 UI 스레드와 통신한다.
      - 그런 다음 다른 URL 요청이 시작된다.
  - 3단계: 응답 읽기
    - 응답 본문(페이로드)이 들어오기 시작하면 네트워크 스레드는 필요한 경우 **스트림의 처음 몇 바이트를 확인**합니다.
    - 응답의 Content-Type 헤더는 데이터 유형을 말해야 하지만, 누락되거나 잘못되었을 수 있으므로 [MIME 유형 스니핑](https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/MIME_types)이 여기서 수행된다.
    - 이것은 [소스 코드](https://source.chromium.org/chromium/chromium/src/+/main:net/base/mime_sniffer.cc;l=5)에서 설명된대로 까다로운 작업이다.
    - 다른 브라우저가 콘텐츠 유형/페이로드 쌍을 처리하는 방법을 보려면 주석을 읽으면 된다.
    - 응답이 HTML 파일인 경우 다음 단계는 렌더러 프로세스에 데이터를 전달하는 것이지만, `zip` 파일이나 다른 파일인 경우 다운로드 요청이므로 다운로드 관리자로 데이터를 전달한다.
    - 세이프 브라우징 확인이 이루어지기도 한다.
      - 도메인과 응답 데이터가 알려진 악성 사이트와 일치하는 것으로 보이면 네트워크 스레드가 경고 페이지를 표시하도록 경고한다.
      - 또한, 민감한 사이트 간 데이터가 렌더러 프로세스에 전달되지 않도록 하기 위해 **CORB 검사**가 수행된다.
- 4단계 : 렌더러 프로세스 찾기
  - 모든 검사가 완료되고 네트워크 스레드가 요청된 사이트로 이동해야 한다고 확신하면 네트워크 스레드는 데이터가 준비되었음을 UI 스레드에게 알린다.
  - 그런 다음 UI 스레드는 **웹 페이지 렌더링을 수행할 렌더러 프로세스를 찾는다.**
  - 네트워크 요청이 응답을 받는 데 수백 밀리 초가 걸릴 수 있으므로 이 프로세스의 속도를 높이기 위한 최적화가 적용된다.
  - UI 스레드가 2단계에서 네트워크 스레드에 URL 요청을 보낼 때 탐색 중인 사이트를 이미 알고 있다.
    - UI 스레드는 네트워크 요청과 병렬로 렌더러 프로세스를 사전에 찾거나 시작하려고 노력한다.
    - 이렇게 하면 모든 것이 예상대로 진행되었을 때, 렌더러 프로세스는 네트워크 스레드가 데이터를 수신했을 때 이미 대기 위치에 있다.
    - 탐색이 교차 사이트로 리다이렉션 되는 경우, 이 대기 프로세스가 사용되지 않을 수 있으며 이 경우 다른 프로세스가 필요할 수 있습니다.
- 5단계: 탐색 커밋
  - 이제 데이터와 렌더러 프로세스가 준비되었으므로 탐색을 커밋하기 위해 브라우저 프로세스에서 렌더러 프로세스로 IPC가 전송된다.
  - 또한 렌더러 프로세스가 HTML 데이터를 계속 수신할 수 있도록, 데이터 스트림을 전달한다.
  - 브라우저 프로세스가 렌더러 프로세스에서 커밋이 발생했다는 확인을 받으면 탐색이 완료되고 문서 로드 단계가 시작된다.
    - 이때 주소 표시줄이 업데이트 되고, 보안 표시 및 사이트 설정 UI에 새 페이지의 사이트 정보가 반영된다.
    - 탭의 세션 기록이 업데이트 되어 뒤로/앞으로 버튼이 방금 탐색한 사이트를 통해 이동한다.
    - 탭이나 창을 닫을 때, 탭/세션 복원을 용이하게 하기 위해 세션 기록이 디스크에 저장된다.
- 추가 단계 : 초기 로드 완료
  - 탐색이 커밋되면 렌더러 프로세스는 리소스 로드를 계속하고 페이지를 렌더링한다.
    > 이 단계에서 일어나는 일에 대해서는 다음 포스트에서 자세히 다룬다.
  - 렌더러 프로세스가 렌더링을 완료하면 IPC를 다시 브라우저 프로세스로 보낸다.
    - 이는 페이지의 모든 프레임에서 `onload` 이벤트가 발생하고 실행이 완료된 후이다.
  - 이 시점에서 UI 스레드는 탭에서 로딩 스피너를 중지한다.
  - 클라이언트 측 자바스크립트는 이 시점 이후에도 여전히 추가 리소스를 로드하고 새 뷰를 렌더링할 수 있기 때문에 완료라고 말한다.
- 다른 사이트로 이동
  - 간단한 네비게이션이 완성되었지만, 사용자가 주소 표시줄에 다른 URL을 다시 입력하면 어떻게 될까?
  - 브라우저 프로세스는 동일한 단계를 거쳐 다른 사이트로 이동한다.
    - 그러기 전에, 현재 렌더링 된 사이트가 `beforeunload` 이벤트에 관심이 있는지 알아야 한다.
  - `beforeunload` 는 **"이 페이지를 떠나시겠습니까?"**를 만들 수 있다.
  - 자바스크립트 코드를 포함하여 탭 내부의 모든 것은 **렌더러 프로세스**에 의해 처리되므로 브라우저 프로세스는 새 탐색 요청이 들어올 때, **현재 렌더러 프로세스를 확인**해야 한다.
    > 💡 무조건 `beforeunload` 핸들러를 추가하지 말아라.
    >
    > - 네비게이션을 시작하기 전에 핸들러를 실행해야 하므로 더 많은 대기 시간이 발생한다.
    > - 이 이벤트 핸들러는 필요한 경우(사용자가 페이지에 입력한 데이터가 손실될 수 있다는 경고를 받아야 하는 경우 등)에만 추가해야 한다.
  - 탐색이 렌더러 프로세스에서 시작된 경우, 렌더러 프로세스는 `beforeunload` 이벤트 핸들러를 확인한다.
    - 사용자가 링크를 클릭했거나, 클라이언트 측 자바스크립트가 `window.location = "https://newsite.com"` 를 실행된 경우
    - 그 다음 브라우저 프로세스 시작 탐색과 동일한 프로세스를 거친다.
    - 유일한 차이점은 **탐색 요청이 렌더러 프로세스에서 브라우저 프로세스로 시작된다는 점**이다.
  - 현재 렌더링 된 사이트가 아닌 다른 사이트로 새 탐색이 수행되면, 현재 렌더링 프로세스가 `unload` 와 같은 이벤트를 처리하기 위해 유지되는 동안 **새 탐색을 처리하기 위해 별도의 렌더링 프로세스가 호출된다.**
    - 자세한 내용은 [페이지 수명 주기 상태 개요 및 페이지 수명 주기 API](https://developer.chrome.com/blog/page-lifecycle-api/#overview_of_page_lifecycle_states_and_events)를 사용하여 이벤트에 연결하는 방법을 참조
- 서비스 워커의 경우
  - 이 탐색 프로세스에 대한 최근 변경 사항 중 하나는 [서비스 워커](https://developer.chrome.com/docs/workbox/service-worker-overview/)의 도입이다.
    > 서비스 워커: 웹 브라우저와 웹 서버 간의 프록시 역할을 하는 특수 자바스크립트 자산
    >
    > [서비스 워커와 캐시 스토리지](https://web.dev/i18n/ko/service-workers-cache-storage/)
  - 서비스 워커는 애플리케이션 코드에 네트워크 프록시를 작성하는 방법이다.
    - 웹 개발자가 로컬로 캐시할 항목과 네트워크에서 새 데이터를 가져올 시기를 더 잘 제어할 수 있다.
    - 서비스 워커가 캐시에서 페이지를 로드하도록 설정되어 있으면, 네트워크에서 데이터를 요청할 필요가 없다.
  - 기억해야 할 중요한 부분은 **서비스 워커가 렌더러 프로세스에서 실행되는 자바스크립트 코드라는 점**입니다.
    - 그러나 탐색 요청이 들어올 때 브라우저 프로세스는 사이트에 서비스 워커가 있는지 어떻게 알 수 있을까?
  - 서비스 워커가 등록되면 서비스 워커의 스코프가 참조로 유지된다.
    > 스코프에 대한 자세한 내용은 [The Service Worker Lifecycle](https://web.dev/service-worker-lifecycle/) 참조
    - 탐색이 발생하면 네트워크 스레드는 **등록된 서비스 워커 범위에 대해 도메인을 확인**하고 서비스 워커가 해당 URL에 등록된 경우 UI 스레드는 서비스 워커 코드를 실행하기 위해 렌더러 프로세스를 찾는다.
      - 서비스 워커는 캐시에서 데이터를 로드하여 네트워크에서 데이터를 요청할 필요가 없도록 하거나, 네트워크에서 새 리소스를 요청할 수 있다.
- 네비게이션 프리로드
  - 서비스 작업자가 결국 네트워크에서 데이터를 요청하기로 결정하면 브라우저 프로세스와 렌더러 프로세스 간의 왕복으로 지연이 발생할 수 있다.
    - 네비게이션 프리로드([Navigation Preload](https://web.dev/navigation-preload/))는 서비스 워커 시작과 병렬로 리소스를 로드하여 이 프로세스의 속도를 높이는 메커니즘이다.
    - 헤더로 이러한 요청을 표시하여 서버가 이러한 요청에 대해 다른 콘텐츠를 보낼지 결정할 수 있도록 한다.
    - 예를 들어, 전체 문서 대신 업데이트 된 데이터만 전송
- 마무리
  - 이 글에선 탐색 중에 발생하는 일과 응답 헤더 및 클라이언트 측 자바스크립트와 같은 웹 애플리케이션 코드가 브라우저와 상호 작용하는 방식을 살펴보았다.
  - 브라우저가 네트워크에서 데이터를 가져오기 위해 거치는 단계를 알면 내비게이션 사전 로드와 같은 API가 개발된 이유를 더 쉽게 이해할 수 있다.

> 다음 : [렌더러 프로세스의 내부 작업 : 브라우저가 페이지를 렌더링하기 위해 HTML/CSS/JavaScript를 평가하는 방법](https://developer.chrome.com/blog/inside-browser-part2/)

### [Type challenges](https://github.com/type-challenges/type-challenges)

- PartialByKeys (failed)
  - 두 객체를 `&` 로 결합하고 평탄화(`Flatten`)

```typescript
type Flatten<T> = {
  [P in keyof T]: T[P];
};

type PartialByKeys<T, K extends keyof T = keyof T> = Flatten<{[Key in Exclude<keyof T, K>]: T[Key]} & {[Key in K]?: T[Key]}>
```


- RequiredByKeys
  - `-?` : 옵셔널을 제거합니다. = `required` 상태가 됩니다.

```typescript
type Flatten<T> = {
  [K in keyof T]: T[K]
}

type RequiredByKeys<T, K extends keyof T = keyof T> = Flatten<Omit<T, K> & { [Key in K]-?: T[Key] }>
```

### Modulized Tailwindcss 

```css
.default-popup-close-btn {
  @apply absolute top-6 right-6 text-gray-400 hover:text-gray-600;
}
```

```typescript
import style from "./default-modal.module.css";

<button className={style["default-popup-close-btn"]} onClick={handleHide}>
  <X className="w-7 h-7" />
</button>
```

## 2023-02-08

### 스토리북 문서화 자동완성

- 컴파운드 컴포넌트 스토리북 Control 타입 자동 완성하기
  - How to make compound component with `forwardRef` 중, `Object.assign` 방식을 차용하고, 컴포넌트 타입(예를 들어, `FC` 제네릭 활용)을 명시

```tsx
...

const AvatarLabeled: FC<AvatarLabeledProps> = Object.assign(
  forwardRef(
    (
    
...
```
