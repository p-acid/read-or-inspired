## 2023-02-01

### [Type challenges](https://github.com/type-challenges/type-challenges)

- ReplaceKeys (Failed)

```typescript
type ReplaceKeys<U, T, Y> = {
  [Key in keyof U]: Key extends T
    ? Key extends keyof Y
      ? Y[Key]
      : never
    : U[Key];
};
```

- Remove Index Signature (Failed)
  - 역으로 시그니처 키 타입에 해당하는 타입들을 `extends` 로 비교하여 시그니쳐 인덱스 구별

```typescript
type SignatureKey = string | number | symbol;

type RemoveIndexSignature<T> = {
  [Key in keyof T as SignatureKey extends keyof T[Key] ? never : Key]: T[Key];
};
```

## 2023-02-02

### [Type challenges](https://github.com/type-challenges/type-challenges)

- Percentage Parser (Failed)

```typescript
type PercentageParser<A extends string> = A extends `${infer Sign}${infer B}`
  ? Sign extends SignType
    ? [Sign, ...(B extends `${infer Number}%` ? [Number, "%"] : [B, ""])]
    : ["", ...(A extends `${infer Number}%` ? [Number, "%"] : [A, ""])]
  : ["", "", ""];
```

- Drop Char

```typescript
type DropChar<
  S extends string,
  C extends string
> = S extends `${infer L}${C}${infer R}` ? `${DropChar<`${L}${R}`, C>}` : S;
```

## 2023-02-06

### [Type challenges](https://github.com/type-challenges/type-challenges)

- Minus One (failed)

```typescript
// 문자열을 앞 뒤로 바꿔주는 타입 제네릭: '123' -> '321'
type Reverse<
  S extends string,
  A extends string = ""
> = S extends `${infer F}${infer R}` ? Reverse<R, `${F}${A}`> : A;

//  숫자에서 1을 빼는 타입 제네릭 : '1' -> '0', '5' -> '4', '0' -> '9'
type DigitMinusOne<D extends string> =
  "09876543210" extends `${string}${D}${infer R}${string}` ? R : never;

// 뒤집어진 숫자에서 1을 빼는 타입 제네릭: '5' -> '4', '01' -> '9', '51' -> '41', '001' -> '99'
type RevMinusOne<T extends string> = T extends `${infer F}${infer N}${infer R}`
  ? // 만약, T가 두 자릿수 이상의 숫자라면
    F extends "0"
    ? `9${RevMinusOne<`${N}${R}`>}`
    : `${DigitMinusOne<F>}${N}${R}`
  : // 만약, T가 한 자릿수 숫자라면
  T extends "0"
  ? "1-"
  : T extends "1"
  ? ""
  : DigitMinusOne<T>;

// 1을 더하는 타입 제네릭: '0' -> '1', '4' -> '9', '9' -> '0'
type DigitPlusOne<D extends string> =
  "01234567890" extends `${string}${D}${infer R}${string}` ? R : never;

// 뒤집어진 숫자에서 1을 더하는 타입 제네릭: '4' -> '9', '9' -> '01', '41' -> '51', '99' -> '001'
type RevPlusOne<T extends string> = T extends `${infer F}${infer N}${infer R}`
  ? // if `T` is a multi-digit number like '01', '55' or '123'
    F extends "9"
    ? `0${RevPlusOne<`${N}${R}`>}`
    : `${DigitPlusOne<F>}${N}${R}`
  : // if `T` is a single-digit number like '0', '1' or '8'
  T extends "9"
  ? "01"
  : DigitPlusOne<T>;

/*
 * 최종 타입 제네릭
 */
type MinusOne<T extends number> = `${T}` extends `-${infer AbsT}`
  ? // 만약, T가 음수일 경우 절댓값에 1을 더하고 "-" 사인을 붙여줌
    `-${Reverse<
      RevPlusOne<Reverse<AbsT>>
    >}` extends `${infer Res extends number}`
    ? Res
    : never
  : // 양수일 경우, 마이너스를
  Reverse<RevMinusOne<Reverse<`${T}`>>> extends `${infer Res extends number}`
  ? Res
  : 0;
```

- PickByType

```typescript
type PickByType<T, U> = {
  [Key in keyof T as T[Key] extends U ? Key : never]: T[Key];
};
```

- StartsWith

```typescript
type StartsWith<T extends string, U extends string> = T extends `${U}${string}`
  ? true
  : false;
```

- EndsWith

```typescript
type EndsWith<T extends string, U extends string> = T extends `${string}${U}`
  ? true
  : false;
```

### 최신 웹 브라우저 살펴보기

> 원본 글 : [Inside look at modern web browser (part 1)](https://developer.chrome.com/blog/inside-browser-part1/)
>
> 1부 내용 : 핵심 컴퓨팅 용어와 크롬 다중 프로세스 아키텍쳐

- 컴퓨터의 핵심은 CPU와 GPU
  - 브라우저 실행 환경을 이해하기 위한 컴퓨터 부품
  - CPU(Central Processing Unit)
    - 중앙 처리 장치
    - 다양한 작업을 하나씩 처리할 수 있다.
    - 과거에는 대부분 단일 칩이었으나, 최신 하드웨어는 둘 이상의 코어로 더 좋은 성능을 제공하는 경우가 많다.
  - GPU(Graphics Processing Unit)
    - 그래픽 처리 장치
    - CPU와 달리 간다한 작업을 처리하며, 여러 코어에 걸쳐있다.
    - 그래픽 처리를 위한 장치
    - 최근 몇 년 동안 GPU 가속 컴퓨팅을 통한 GPU 단독 컴퓨팅이 가능해지고 있다.
  - 일반적으로 응용프로그램은 운영 체제에서 제공하는 메커니즘을 사용하여 CPU 및 GPU에서 실행된다.
- 프로세스 및 스레드에서 프로그램 및 실행
  - 응용 프로그램 실행으로 설명하는 프로세스와 스레드
    1. 응용 프로그램 시작 및 프로세스 생성
    2. 운영 체제가 작업할 메모리의 공간을 프로세스에 제공
    3. 모든 애플리케이션 상태를 해당 메모리 공간에 보관
    4. 응용 프로그램을 닫으면 프로세스도 사라지고 운영 체제에서 메모리를 확보
  - 프로세스는 다른 작업을 실행하기 위해 운영 체제에 요청할 수 있다.
  - 이러면, 메모리 다른 부분이 새 프로세스에 할당
  - 두 프로세스가 통신해야 하는 경우 **IPC(Inter Process Communication)**를 사용하여 가능
  - 많은 응용 프로그램은 작업자 프로세스가 응답하지 않은 경우, 응용 프로그램의 다른 부분을 실행하는 다른 프로세스를 중단하지 않고 다시 시작할 수 있도록 이러한 방식으로 설계되었다.
- 브라우저 아키텍쳐
  - 프로세스와 스레드를 사용하여 웹 브라우저를 구축하는 방법
    - 여러 스레드가 있는 하나의 프로세스이거나 IPC를 통해 통신하는 여러 프로세스일 수 있다.
    - 중요한 점은, 서로 다른 아키텍쳐가 구현 세부 사항이라는 것이다.
    - 웹 브라우저를 구축하는 표준 사양은 없다.
    - 한 브라우저의 접근 방식은 다른 브라우저와 완전히 다를 수 있다.
    - 해당 글에선 크롬 최신 아키텍쳐를 사용한다.
  - 크롬 아키텍쳐
    - 맨 위에는 응용 프로그램의 다른 부분을 관리하고 다른 프로세스와 조정되는 브라우저 프로세스가 있다.
    - 렌더러 프로세스의 경우 여러 프로세스가 생성되어 각 탭에 할당된다.
      - 아주 최근까지 크롬은 가능한 경우 각 탭에 프로세스를 제공했다.
      - 하지만 이제 `iframe` 을 포함하여 각 사이트에 자체 프로세스를 제공하려 시도한다.
- 프로세스 목록

  | 제어 대상 | 설명                                                                                                                                                                                     |
  | --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
  | 브라우저  | 주소 표시줄, 북마크, 뒤로 및 앞으로 버튼을 포함하여 애플리케이션의 크롬 부분을 제어한다. <br/> 또한, 네트워크 요청 및 파일 액세스와 같은 웹 브라우저의 보이지 않는 권한 부분을 처리한다. |
  | 렌더러    | 웹사이트가 표시되는 탭 내부의 모든 것을 제어한다.                                                                                                                                        |
  | 플러그인  | 예를 들어, 플래시와 같이 웹 사이트에서 사용하는 모든 플러그인을 제어한다.                                                                                                                |
  | GPU       | 다른 프로세스와 별도로 GPU 작업을 처리한다. <br/> GPU가 여러 앱의 요청을 처리하고 동일한 표면에 그리기 때문에 다른 프로세스로 분리된다.                                                  |

  <br/>
  - 이외에도 확장 프로세스 및 유틸리티 프로세스 등도 존재한다.
  - 크롬에서 실행 중인 프로세스 수를 확인하려면 오른쪽 상단 모서리에 있는 옵션 메뉴 아이콘을 클릭하고 도구 더보기에서 작업 관리자를 열면 된다.
  - 그러면 현재 실행 중인 프로세스 목록과 사용 중인 CPU/메모리 양이 표시된 창이 열린다.

- 크롬 다중 프로세스 아키텍쳐의 이점
  - 크롬은 **다중 렌더러 프로세스**를 사용한다.
    - 간단하게 각 탭에 자체 렌더러 프로세스가 있다고 생각할 수 있다.
    - 3개의 탭이 열려 있고 각 탭이 독립적인 렌더러 프로세스에 의해 실행된다고 가정했을 때, 한 탭이 응답하지 않으면, 응답하지 않는 탭을 닫고 다른 탭을 활성 상태로 유지하면서 계속 진행할 수 있다.
    - 모든 탭이 한 프로세스라면, 한 탭이 응답하지 않을 때 모든 탭이 응답하지 않는다.
  - 브라우저 작업을 여러 프로세스로 분리하는 또 다른 이점은 보안 및 샌드박싱이다.
    - 운영 체제는 프로세스 권한을 제한하는 방법을 제공하기에 브라우저는 특정 기능에서 특정 프로세스를 샌드박싱할 수 있다.
      - 샌드박싱이란 외부로부터 들어온 프로그램이 보호된 영역에서 동작해 시스템이 부정하게 조작되는 것을 막는 보안 형태
    - 예를 들어, 크롬 브라우저는 렌더러 프로세스와 같이 임의의 사용자 입력을 처리하는 프로세스에 대한 임의 파일 액세스를 제한한다.
  - 프로세스에는 고유한 개인 메모리 공간이 있기 때문에 공통 인프라(예를 들어, 크롬의 자바스크립트 엔진인 V8)의 복사본을 포함하는 경우가 많다.
    - 이는 동일한 프로세스 내부의 스레드인 경우 공유할 수 없기 때문에, 더 많은 메모리 사용량을 의미한다.
    - 메모리를 절약하기 위해 크롬은 가동할 수 있는 프로세스 수를 제한한다.
    - 한도는 기기의 메모리 및 CPU 성능에 따라 다르지만, 크롬이 한도에 도달하면 한 프로세스에서 동일한 사이트의 여러 탭을 실행하기 시작한다.
- 더 많은 메모리 절약 - 크롬의 서비스
  - 동일한 접근 방식이 브라우저 프로세스에 적용된다.
    - 크롬은 브라우저 프로그램의 각 부분을 서비스로 실행하여, 여러 프로세스로 쉽게 분할하거나 하나로 통합할 수 있도록 아키텍쳐를 변경하고 있다.
  - 일반적으로 크롬이 강력한 하드웨어에서 실행될 때엔 각 서비스를 다른 프로세스로 분할하여 더 많은 안정성을 제공한다.
    - 하지만, 리소스가 제한된 장치에 있는 경우 크롬은 서비스를 하나의 프로세스로 통합하여 메모리 공간을 절약한다.
    - 메모리 사용량을 줄이기 위해 프로세스를 통합하는 유사한 접근 방식이 안드로이드와 같은 플랫폼에서 사용되었다.
- 프레임 별 렌더러 프로세스 - 사이트 격리
  - 사이트 격리는 각 교차 사이트 `iframe` 에 대해 렌더러 프로세스를 실행하는 최근 도입된 크롬의 기능이다.
  - 우리는 서로 다른 사이트 간에 메모리 공간을 공유하는 단일 렌더러 프로세스에서 사이트 간 `iframe` 을 실행할 수 있는 탭 모델당 하나의 렌더러 프로세스에 대해 이야기했다.
  - 동일한 렌더러 프로세스에서 두 가지 웹 사이트(a.com, b.com)를 실행하는 것이 괜찮아보일 수 있다.
    - 동일 출처 정책은 웹의 핵심 보안 모델이다.
    - 한 사이트가 동의 없이 다른 사이트의 데이터에 액세스 할 수 없도록 한다.
    - 이 정책을 우회하는 것이 보안 공격의 주요 목표이다.
  - 프로세스 격리는 사이트를 분리하는 가장 효과적인 방법이다.
    - 멜트다운과 스펙터로 프로세스를 사용하여 사이트를 분리해야 한다는 것이 더욱 분명해졌다.
    - 크롬 67부터 기본적으로 데스크톱에서 사이트 격리가 활성화되어 있으므로 탭의 각 교차 사이트 `iframe` 은 별도의 렌더러 프로세스를 가져온다.
  - 사이트 격리를 활성화 하는 것은 다년간의 엔지니어링 노력에서 비롯된다.
    - 사이트 격리는 다른 렌더러 프로세스를 할당하는 것처럼 간단하지 않다.
    - `iframe` 이 서로 커뮤니케이션 하는 방식을 근본적으로 바꾼다.
    - 다른 프로세스에서 실행되는 `iframe` 이 있는 페이지에서 개발자 도구를 여는 것은 개발자 도구가 매끄럽게 보이도록 백그라운드 작업을 구현해야 한다는 것을 의미한다.
    - 페이지에서 단어를 찾기 위해 Ctrl+F를 실행하는 것조차 다른 렌더러 프로세스에서 검색하는 것을 의미한다.
    - 브라우저 엔지니어가 사이트 격리 릴리스를 주요 이정표로 언급하는 이유를 알 수 있다.

> 다음: [Inside look at modern web browser (part 2)](https://developer.chrome.com/blog/inside-browser-part2/)


## 2023-02-07

### [How to make compound component with `forwardRef`](https://stackoverflow.com/questions/70202711/how-to-attach-a-compound-component-when-using-react-forward-ref-property-does-n)

- 타입 확장 및 객체 `export` 방식

```tsx
interface IPanel
  extends React.ForwardRefExoticComponent<
    PanelProps & React.RefAttributes<HTMLDivElement>
  > {
  Header: typeof PanelHeader;
  Content: typeof PanelContent;
}
```

```tsx
const forwardRef = React.forwardRef<HTMLDivElement, PanelProps>(
  (props, ref): JSX.Element => {
    return (
      <PanelComponent
        {...props}
        forwardedRef={ref}
        data-testid={PANEL_TEST_ID}
      />
    );
  }
);

export const Panel = {
  ...forwardRef,
  Header: PanelHeader,
  Content: PanelContent
} as IPanel;
```

- `Object.assign` 방식

```tsx
export const Panel = Object.assign(
  React.forwardRef(
    (props: PanelProps, ref: React.Ref<HTMLDivElement>): JSX.Element => {
      return (
        <PanelComponent
          {...props}
          forwardedRef={ref}
          data-testid={PANEL_TEST_ID}
        />
      );
    }
  ),
  {
    Header: PanelHeader,
    Content: PanelContent
  }
);
```

