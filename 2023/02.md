## 2023-02-01

### [Type challenges](https://github.com/type-challenges/type-challenges)

- ReplaceKeys (Failed)

```typescript
type ReplaceKeys<U, T, Y> = { 
  [Key in keyof U]: 
    Key extends T 
      ? Key extends keyof Y 
        ? Y[Key] 
        : never 
      : U[Key] 
  }
```

- Remove Index Signature (Failed)
  - 역으로 시그니처 키 타입에 해당하는 타입들을 `extends` 로 비교하여 시그니쳐 인덱스 구별

```typescript
type SignatureKey = string | number | symbol

type RemoveIndexSignature<T> = { [Key in keyof T as SignatureKey extends keyof T[Key] ? never : Key]: T[Key]; }
```

## 2023-02-02

### [Type challenges](https://github.com/type-challenges/type-challenges)

- Percentage Parser (Failed)

```typescript
type PercentageParser<A extends string> = A extends `${infer Sign}${infer B}` 
  ? Sign extends SignType
    ? [Sign, ...(B extends `${infer Number}%` ? [Number, '%'] : [B, ''])]
    : ['', ...(A extends `${infer Number}%` ? [Number, '%'] : [A, ''])]
  : ['', '' , '']
```

- Drop Char

```typescript
type DropChar<S extends string, C extends string> = S extends `${infer L}${C}${infer R}`
  ? `${DropChar<`${L}${R}`, C>}`
  : S
```

## 2023-02-06

### [Type challenges](https://github.com/type-challenges/type-challenges)

- Minus One (failed)

```typescript
// 문자열을 앞 뒤로 바꿔주는 타입 제네릭: '123' -> '321'
type Reverse<S extends string, A extends string = ''> = S extends `${infer F}${infer R}` ? Reverse<R, `${F}${A}`> : A

//  숫자에서 1을 빼는 타입 제네릭 : '1' -> '0', '5' -> '4', '0' -> '9'
type DigitMinusOne<D extends string> = '09876543210' extends `${string}${D}${infer R}${string}` ? R : never

// 뒤집어진 숫자에서 1을 빼는 타입 제네릭: '5' -> '4', '01' -> '9', '51' -> '41', '001' -> '99'
type RevMinusOne<T extends string> = T extends `${infer F}${infer N}${infer R}`
  // 만약, T가 두 자릿수 이상의 숫자라면
  ? F extends '0'
    ? `9${RevMinusOne<`${N}${R}`>}`
    : `${DigitMinusOne<F>}${N}${R}`
  // 만약, T가 한 자릿수 숫자라면
  : T extends '0'
    ? '1-'
    : T extends '1'
      ? ''
      : DigitMinusOne<T>

// 1을 더하는 타입 제네릭: '0' -> '1', '4' -> '9', '9' -> '0'
type DigitPlusOne<D extends string> = '01234567890' extends `${string}${D}${infer R}${string}` ? R : never

// 뒤집어진 숫자에서 1을 더하는 타입 제네릭: '4' -> '9', '9' -> '01', '41' -> '51', '99' -> '001'
type RevPlusOne<T extends string> = T extends `${infer F}${infer N}${infer R}`
  // if `T` is a multi-digit number like '01', '55' or '123'
  ? F extends '9'
    ? `0${RevPlusOne<`${N}${R}`>}`
    : `${DigitPlusOne<F>}${N}${R}`
  // if `T` is a single-digit number like '0', '1' or '8'
  : T extends '9'
    ? '01'
    : DigitPlusOne<T>

/*
 * 최종 타입 제네릭
 */
type MinusOne<T extends number> = `${T}` extends `-${infer AbsT}`
  // 만약, T가 음수일 경우 절댓값에 1을 더하고 "-" 사인을 붙여줌
  ? `-${Reverse<RevPlusOne<Reverse<AbsT>>>}` extends `${infer Res extends number}` ? Res : never
  // 양수일 경우, 마이너스를 
  : Reverse<RevMinusOne<Reverse<`${T}`>>> extends `${infer Res extends number}` ? Res : 0
```

- PickByType

```typescript
type PickByType<T, U> = {
  [Key in keyof T as T[Key] extends U ? Key : never]: T[Key]
}
```

- StartsWith

```typescript
type StartsWith<T extends string, U extends string> = T extends `${U}${string}` ? true : false
```

- EndsWith

```typescript
type EndsWith<T extends string, U extends string> = T extends `${string}${U}` ? true : false
```




