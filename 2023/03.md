# 2023-03-04

## [Type challenges](https://github.com/type-challenges/type-challenges)

- SimpleVue (failed)

```ts
type Computed<T> = {
  [K in keyof T]: T[K] extends (...args: any[]) => infer R ? R : T[K];
};

interface Options<D, C, M> {
  data?: () => D;
  computed?: C & ThisType<D & Computed<C> & M>;
  methods?: M & ThisType<D & Computed<C> & M>;
}
```

<br/>

# 2023-03-05

## 프레임워크에 대한 이야기

### 프레임워크란?

- 사전적 정의는 **무언가를 만들 수 있는 지지 구조**
- 앵귤러의 경우 서비스, 컴포넌트와 파이프 같은 기본 요소를 사용하여 애플리케이션 빌드에 필요한 구조를 제공

<br/>

#### 프레임워크와 라이브러리 비교

- 라이브러리와 프레임워크의 차이는 **프레임워크는 코드를 호출하고, 코드는 라이브러리를 호출한다**는 점
- 앵귤러와 Moment.js의 비교
  - 앵귤러의 경우 개발자가 **코드로 채울 수 있는 구조**와 표준 작업에 도움이 되는 **유틸리티 세트(`HttpClient` 와 같은)**를 제공한다.
  - Moment.js는 애플리케이션 **코드를 어떻게 구성해야 하는지에 대한 특정 형식을 제공하지 않는다.**

> 리액트는 프레임워크인가 라이브러리인가. 이 질문에 대한 대답의 힌트를 **프레임워크 방식**에서 얻을 수 있다.

<br/>

#### 프레임워크 방식

- Moment.js가 코드 작성 방식을 강요하지 않는 것에 비해 앵귤러는 독선적이다.
- 언어 측면에서는 일반 ECMAScript로도 작성 가능하지만 타입스크립트가 생태계 표준이다.
- 의존성 주입 측면에서는 요소가 앵귤러 애플리케이션에서 통신할 수 있도록 하려면 유형에 따라 의존성 주입 메커니즘을 사용하여 의존성 주입을 해야 한다.
- 앵귤러는 옵저버블을 활용하는 RxJS를 사용하고 프로미스 기반 라이브러리를 통합해야 하는 경우 추가 작업을 수행해야 한다.
- 이런 제약 조건들이 좋거나 나쁜 것은 아니지만, 프로젝트에 적합한 도구인지를 평가하기 위해선 **프레임워크의 방식을 분석하는 것**이 중요하다.

<br/>

#### 리액트에 대해 이야기해보자

- 리액트는 **사용자 인터페이스 구축을 위한 자바스크립트 라이브러리**라고 정의되어 있다.
  - 그러나 현실은 이 보다 더 복잡하다.
- 리액트 주요 제약 사항은 **선언적 패러다임**의 사용이다.
  - 저자는 선언적 패턴은 리액트 방식의 일부라고 생각하기에 리액트를 프레임워크라고 믿는다.

> 작업 처리에서 프레임워크 방식을 사용하고 있다면 프레임워크라고 할 수 있다.

<br/>

### 자바스크립트 프레임워크 연혁

<br/>

#### 제이쿼리

- 존 레식이 만들었으며, 모든 자바스크립트 프레임워크의 모체가 됐다.
- 중요 기능은 **선택자 구문**이다.
- 웹 개발의 초석 역할을 맡았었다.

<br/>

#### 앵귤러JS

- 미스코 헤브리에 의해 부수적인 프로제긑로 개발되었고, 이후 구글 직원이 되어 지금은 구글 엔지니어가 관리한다.
- SPA를 주류로 만드는데 큰 역할을 했다.
- 가장 주목할 만한 기능은 **양방향 데이터 바인딩**이다.
  - 하지만 양방향 데이터 바인딩은 대규모 어플리케이션에선 적합하지 않았다.

<br/>

#### 리액트

- 2011년 페이스북에서 만들어 2013년 오픈소스로 공개한 프론트엔드 라이브러리이다.
- 앞에서도 말했듯이 선언적 패러다임으로 동작한다.
- 기술적으론 리액트는 렌더링 라이브러리다.

<br/>

#### 앵귤러

- 앵귤러는 앵귤러JS의 새로운 버전으로 시작되었고, 엔터프라이즈 세계를 타깃으로 삼았다.
- 타입스크립트가 사실상 앵귤러 작업의 표준이었기에 많은 자바 및 C# 개발자의 프론트엔드 접근에 도움이 되었다.

<br/>

# 2023-03-06

### 기술 부채

- 워드 커닝햄이 제시한 개념
- 지저분한 솔루션을 선택할 수록 부채가 늘어난다.
  - 부채란 기존 기능의 변경이나 새로운 기능의 추가에 따르는 비용

<br/>

#### 프레임워크 비용

- 저자는 프레임워크의 활용이 기술 부채를 갖고 간다고 생각한다.
- 본인의 문제를 해결하는데 다른 사람의 코드를 사용하는 것은 최적일 수 없고, 최적이 아닌 방법을 선택하면 부채가 생긴다.
- 시간이 지남에 따라, 소프트웨어의 변경이 필요한 시점이 다가오고 프레임워크는 이런 변경에서 장애물이 된다.

<br/>

### 기술 투자

- 모든 부채가 나쁜 것은 아니기에 프레임워크를 무조건적으로 반대하지 않는다.
- 중요한 점은 부채 자체가 아니라 부채가 필요한 이유다.

<br/>

## 렌더링

- 모든 웹 애플리케이션에서 가장 중요한 기능은 데이터를 표시하는 것, 즉 렌더링이다.
- W3C는 프로그래밍 방식으로 요소를 렌더링 하는 방식을 DOM으로 정의했다.

> 이번 장에선 프레임워크 없이 DOM을 효과적으로 조작하는 방법을 배운다.

<br/>

### 문서 객체 모델

- 문서 객체 모델(DOM)은 웹 애플리케이션을 구성하는 요소들을 조작할 수 있는 API다.
- 트리 형태로 구성되어 있으며, 주로 Node 메서드를 사용한다.

<br/>

### 렌더링 성능 모니터링

- 웹용 렌더링 엔진을 설계할 때에는 가독성과 유지 관리성을 염두에 둬야 한다.
  - 또한, 성능도 중요한 요소이다.

<br/>

#### 크롬 개발자 도구

- 크롬 개발자 도구를 열고, `Cmd`/`Ctrl` + `Shift` + `P` 단축키를 통해 명령 메뉴를 표시하여 Show frame per seconds (FPS) meter 메뉴 항목 선택
  - GPU 사용 메모리양 확인 가능

<br/>

#### 사용자 정의 성능 위젯

- `requestAnimationFrame` 콜백을 사용해 현제 렌더링 사이클과 다음 사이클 사이의 시간을 추적하고 콜백이 1초 내에 호출되는 횟수를 추적하면 됨

<br/>

### 렌더링 함수

- 순수 함수를 사용해 요소를 렌더링한다는 것은 DOM 요소가 애플리케이션의 상태에만 의존한다는 뜻이다.
- 순수 함수를 사용하면 테스트 가능성이나 구성 가능성 같은 많은 장점이 있다.
  - 하지만 몇 가지 문제점이 있다. 장 마지막에 알아본다.
